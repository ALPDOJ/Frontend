@namespace Client.Pages.Problem
@using TrueMogician.Extensions.Collections.Tree
@using Blazored.LocalStorage
@using Client.Utils
@using Newtonsoft.Json
@using OneOf.Types
@using TrueMogician.Exceptions
@using Comment = Client.Api.Comment

<Comment 
	@ref="@CommentElement" 
	Author="@Comment.Author.GetDisplayingName()"
	Datetime="@Formatter.FormatDateTimeRelatively(Comment.Time,2)" 
	Actions="@Actions">
	<AvatarTemplate>
		@if (!string.IsNullOrEmpty(Comment.Author.Avatar)) {
			<Avatar Src="@Comment.Author.Avatar" />
		}
		else {
			<Avatar>author.Username ?? author.Id.ToString()</Avatar>
		}
	</AvatarTemplate>
	<ContentTemplate>
		@if (Comment.Content is null) {
			<span><i>该内容已被删除</i></span>
		}
		else {
			<RichTextDisplayer Value="@Comment.Content" />
		}
	</ContentTemplate>
	<ChildContent>
		@if (!Node.IsLeaf) {
			@foreach (var child in Node.Children) {
				<CommentTree Node="@child" OnReply="@OnReply" />
			}
		}
	</ChildContent>
</Comment>

@code {

	[Parameter]
	public ValuedTreeNode<Comment> Node { get; set; }

	[Parameter]
	public EventCallback<int> OnReply { get; set; }

	[CascadingParameter]
	public User CurrentUser { get; set; }

	[Inject]
	public ApiClient Api { get; set; }

	[Inject]
	public MessageService MessageService { get; set; }

	private AntDesign.Comment CommentElement { get; set; }

	private List<Reaction> CurrentReactions { get; set; } = new();

	private Comment Comment => Node.Value;

	private RenderFragment ReplyAction =>
		@<span onclick="@(() => OnReply.InvokeAsync(Comment.Id))">回复</span>;

	private RenderFragment DeleteAction =>
		@<span>
			<AntDesign.Tooltip Title="@("删除")">
				<Icon Type="@IconType.Outline.Delete" OnClick="DeleteComment" />
			</AntDesign.Tooltip>
		</span>;

	private RenderFragment[] Actions {
		get {
			if (Comment.Content is null)
				return Array.Empty<RenderFragment>();
			var result = new List<RenderFragment> {
				ReplyAction
			};
			if (CurrentUser.Role != Role.Student || CurrentUser.Id == Comment.Author.Id)
				result.Add(DeleteAction);
			var more = new List<Reaction>();
			foreach (var reaction in Enum.GetValues<Reaction>()) {
				if ((reaction is Reaction.Like or Reaction.Dislike) || Comment.GetReactionCount(reaction) > 0)
					result.Add(RenderReactAction(reaction));
				else
					more.Add(reaction);
			}
			if (more.Count > 0)
				result.Add(RenderMoreReactions(more));
			return result.ToArray();
		}
	}

	protected override async Task OnInitializedAsync() {
		await base.OnInitializedAsync();
		if (Comment.Reactions is not null)
			CurrentReactions.AddRange(Comment.Reactions.Keys.Where(k => Comment.Reactions[k].Contains(CurrentUser.Id)).Select(Enum.Parse<Reaction>));
	}

	private RenderFragment RenderReactAction(Reaction reaction) {
		var title = reaction switch {
			Reaction.Like => "点赞",
			Reaction.Dislike => "点踩",
			Reaction.Laugh => "笑死",
			Reaction.Hooray => "好耶",
			Reaction.Confused => "不懂",
			Reaction.Heart => "比心",
			Reaction.Rocket => "火箭",
			Reaction.Eyes => "康康",
			_ => throw new EnumValueOutOfRangeException(typeof(Reaction))
		};
		var icon = reaction switch{
			Reaction.Like => "👍",
			Reaction.Dislike => "👎",
			Reaction.Laugh => "🤣",
			Reaction.Hooray => "🎉",
			Reaction.Confused => "🤔",
			Reaction.Heart => "❤",
			Reaction.Rocket => "🚀",
			Reaction.Eyes => "👀",
			_ => throw new EnumValueOutOfRangeException(typeof(Reaction))
		};
		return @<span>
		   <AntDesign.Tooltip Title="@title">
			   <span onclick="@(() => ReactToComment(reaction))">
				   @icon
				   @if (Comment.GetReactionCount(reaction) is var count and > 0) {
					   <Text>@count</Text>
				   }
			   </span>
		   </AntDesign.Tooltip>
		</span>;
	}

	private RenderFragment RenderMoreReactions(IList<Reaction> reactions) =>
		@<Dropdown Placement="@Placement.Right" Trigger="new []{Trigger.Click}">
			<Overlay>
				<div style="display: flex">
					@foreach (var reaction in reactions) {
						@RenderReactAction(reaction)
					}
				</div>
			</Overlay>
			<ChildContent>
				<Button Size="@ButtonSize.Small" Shape="@ButtonShape.Round">
					···
				</Button>
			</ChildContent>
		</Dropdown>;

	private async Task ReactToComment(Reaction reaction) {
		var newReactions = CurrentReactions.ToHashSet();
		var remove = newReactions.Contains(reaction);
		if (remove)
			newReactions.Remove(reaction);
		else
			newReactions.Add(reaction);
		try {
			await Api.ReactToCommentAsync(Comment.ProblemId, Comment.Id, newReactions);
			var commentReactions = Comment.Reactions?.TryGetValue(Enum.GetName(reaction)!, out var result) == true ? result! : new List<int>();
			if (remove)
				commentReactions.Remove(CurrentUser.Id);
			else
				commentReactions.Add(CurrentUser.Id);
			CurrentReactions = newReactions.ToList();
			StateHasChanged();
		}
		catch (ApiException ex) {
			var _ = MessageService.Error($"{ex.StatusCode}: {ex.Message}");
		}
	}

	private async Task DeleteComment() {
		try {
			await Api.DeleteCommentAsync(Comment.ProblemId, Comment.Id);
			Comment.Content = null;
			var _ = MessageService.Success("删除成功");
		}
		catch (ApiException ex) {
			var _ = MessageService.Error($"删除失败: {ex.Message}");
		}
	}
}
